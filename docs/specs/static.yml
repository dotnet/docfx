# Copy assets in template definition to output directory for self contained build
inputs:
  docsets.yml:
  a/docfx.yml: |
    selfContained: true
    template: ../_themes
  b/docfx.yml: |
    selfContained: false
    template: ../_themes
  _themes/template.yml: |
    assets:
    - styles/**
    - scripts/**
  _themes/styles/main.css: css
  _themes/scripts/main.js: js
outputs:
  a/styles/main.css: css
  a/scripts/main.js: js
---
# Liquid template file missing should not crash
noDryRun: true
inputs: 
  docfx.yml: |
    outputType: html
    urlType: pretty
  docs/a.md: Hello `docfx`!
outputs: 
  docs/a/index.html:
  .errors.log: |
    {"message_severity":"warning","code":"liquid-not-found","file":"docs/a.md","line":1,"column":1}
---
# Source file name ending with spaces should not crash
inputs:
  docfx.yml: |
    outputType: html
    urlType: pretty
  docs/a b.. ..md:
  _themes/Conceptual.html.liquid:
outputs:
  docs/a b/index.html:
---
# Treat TOC as JSON when toc.html.tmpl is missing
inputs: 
  docfx.yml: |
    outputType: html
  TOC.md:
outputs: 
  .errors.log: |
    {"message_severity": "error","code": "mustache-not-found","line": 0,"column": 0}
---
# Treat TOC as HTML when toc.html.tmpl is present
inputs: 
  docfx.yml: |
    outputType: html
  TOC.md:
  _themes/ContentTemplate/toc.html.tmpl:
outputs: 
  toc.html:
  toc.json:
---
# Apply template and produce html page when output type is html
# Index page should be handled specially
# Resource file should not be prettify
inputs:
  docfx.yml: |
    outputType: html
    urlType: pretty
  _themes/ContentTemplate/Conceptual.mta.json.js: |
    exports.transform = function (model) {
      model.additional = "additional";
      return {
        content: JSON.stringify(model)
      };
    }
  _themes/Conceptual.html.liquid: |
    <!DOCTYPE html>
      <div>
          {{content}}
      </div>
  a.md: |
    # title
    **strong**
    ~~removed~~
    ![](b.png)
  index.md:
  b.png:
outputs:
  a/index.html: |
    <!DOCTYPE html>
      <div>
        <p>
          <strong>strong</strong>
          <del>removed</del>
          <img alt="" src="../b.png"></img>
        </p>
      </div>
  b.png:
  index.html:
  .publish.json: |
    {
      "files": [
        {"url": "/a/", "additional": "additional"},
        {"url": "/b.png"},
        {"url": "/"}
      ]
    }
---
# Apply template and produce html page when output type is html and urlType is Ugly
inputs:
  docfx.yml: |
    outputType: html
    urlType: ugly
  _themes/Conceptual.html.liquid: |
  a.md:
  index.md:
outputs:
  a.html:
  index.html:
  .publish.json: |
    {
      "files": [
        { "url": "/a.html" },
        { "url": "/index.html"}
      ]
    }
---
# Always ues Docs URL to check redirection rule with document_id as true
inputs:
  docfx.yml: |
    outputType: html
    urlType: Ugly
  redirections.yml: |
    renames:
      a.md: /b.html
  _themes/Conceptual.html.liquid:
  b.md:
outputs:
  b.html:
  .publish.json: |
    {
      "files": [
        { "url": "/a.html", "redirect_url": "/b.html" },
        { "url": "/b.html"}
      ]
    }
---
# Apply template and produce html page with versioning
# 1. Link should be resolved to the physical relative path
# 2. Asset_id should should contains group prefix
inputs:
  docfx.yml: |
    outputType: html
    urlType: ugly
    monikerRange:
      'docs/v1/**': '< netcore-2.0'
    routes:
      docs/v1/: .
    monikerDefinition: '{APP_BASE_PATH}/data/monikers.json'
  _themes/Conceptual.html.liquid: |
    <!DOCTYPE html>
      <div>
          {{content}}
      </div>
  _themes/ContentTemplate/toc.html.js: |
    exports.transform = function (model) {
      return {
        content: model.items
      }
    }
  _themes/ContentTemplate/toc.html.tmpl: |
    <!DOCTYPE html>
      <div>
          {{#content}}
            <li>
            {{#href}} <a class="normal" href="{{ href }}">{{ name }}</a> {{/href}}
            </li>
          {{/content}}
      </div>
  docs/v1/a.md: |
    ---
    monikerRange: netcore-1.0
    ---
    [B](b.md)
  docs/v1/b.md: |
    ---
    monikerRange: netcore-1.1
    ---
  docs/v1/TOC.md: |
    # [A](a.md)
outputs:
  1dd7adba/toc.html: |
    <!DOCTYPE html>
      <div>
        <li>
          <a class="normal" href="../136a42ac/a.html">A</a> 
        </li>
      </div>
  1dd7adba/toc.json: |
    {
      "items": [{"name": "A","href": "../136a42ac/a.html"}],
      "_path": "1dd7adba/toc.html"
    }
  136a42ac/a.html: |
    <!DOCTYPE html>
    <div><p><a href="../218c13d0/b.html" data-linktype="relative-path">B</a></p></div>
  218c13d0/b.html:    
  .manifest.json: |
    {
      "files": [
        {"asset_id": "136a42ac/a.html","output":{".html":{"relative_path":"136a42ac/a.html"}},"group": "136a42ac","version": "< netcore-2.0", "is_moniker_range":true, "source_relative_path": "docs/v1/a.md"},
        {
          "asset_id": "1dd7adba/toc.html",
          "output":{".html":{"relative_path":"1dd7adba/toc.html"}},
          "group": "1dd7adba",
          "version":"< netcore-2.0",
          "is_moniker_range": true,
          "source_relative_path": "docs/v1/TOC.md"
        },
        {"asset_id": "218c13d0/b.html"}
      ]
    }
---
# Verify SDP pipeline
# YAML mime in the SDP document should have a corresponding *.html.primary.js file
# Set config.output.json to false to run *.html.liquid to output static HTML
# Provide *.mta.json.js to transform metadata
# Provide *.html.primary.js and *.html.primary.tmpl to transform json content to HTML
inputs:
  docfx.yml: |
    outputType: html
    urlType: pretty
  _themes/ContentTemplate/schemas/TestData.schema.json: "{\"renderType\": \"content\"}"
  a.yml: |
    #YamlMime:TestData
    prop: value
  _themes/ContentTemplate/TestData.mta.json.js: |
    exports.transform = function (model) {
      model.layout = "test"
      return {
        content: JSON.stringify(model)
      }
    }
  _themes/ContentTemplate/TestData.html.primary.tmpl: |
    <div>{{.}}</div>
  _themes/ContentTemplate/TestData.html.primary.js: |
    exports.transform = function (model) {
      return model.prop;
    }
  _themes/test.html.liquid: |
    <!DOCTYPE html>
      <div>
          {{content}}
      </div>
outputs:
  a/index.html: |
    <!DOCTYPE html>
      <div>
        <div>value</div>

      </div>
---
# Static Build mode for `Data` type SDP
# Should generate json output
# Url should not be prettify
inputs:
  docfx.yml: |
    outputType: html
    urlType: pretty
  a.yml: |
    #YamlMime:TestData
    prop: value
  _themes/ContentTemplate/TestData.json.js: |
    exports.transform = function (model) {
      return {
        content: JSON.stringify({result: model.prop + " has run js data transform"})
      }
    }
  _themes/ContentTemplate/schemas/TestData.schema.json: "{}"
outputs:
  a.json: |
    {"result": "value has run js data transform"}
---
# Referenced image in fallback origin should also be built in static output mode
locale: zh-cn
repos: 
  https://github.com/c/image1#master:
    - files:
        docfx.yml:
        docs/b.png:
  https://github.com/c/image1.zh-cn#master:
    - files:
        docfx.yml: |
          outputType: html
          urlType: ugly
        _themes/Conceptual.html.liquid: |
          {{content}}
        docs/a.md: |
          ![B](b.png)
outputs:
  docs/a.html: |
    <p><img src="b.png" alt="B" data-linktype="relative-path"></p>
  docs/b.png:
  .publish.json: |
    {
      "files": [
        { "url": "/docs/a.html" },
        { "url": "/docs/b.png" }
      ]
    }
---
# File reference in fallback origin should also be resolved to  in static output mode
locale: zh-cn
repos: 
  https://github.com/c/image1#master:
    - files:
        docfx.yml:
        docs/index.md:
  https://github.com/c/image1.zh-cn#master:
    - files:
        docfx.yml: |
          outputType: html
          urlType: ugly
        _themes/Conceptual.html.liquid: |
          {{content}}
        docs/a.md: |
          [引用](index.md)
outputs:
  docs/a.html: |
    <p><a data-linktype="external" href="https://docs.com/docs/">引用</a></p>
  .publish.json: |
    {
      "files": [
        { "url": "/docs/a.html" }
      ]
    }
---
# Prebuild lunr search index as .lunr.json when searchEngine is lunr
inputs:
  docfx.yml: |
    outputType: html
    urlType: pretty
    searchEngine: lunr
  _themes/Conceptual.html.liquid: |
    {{page.search_engine}}
    {{content}}
  a.md: |
    # Markdown Title

    Type `javascript` *here*
outputs:
  a/index.html: |
    lunr <p>Type <code>javascript</code><em>here</em>
  .lunr.json: |
    { "version": "2.3.8", "fields": ["title", "body"] }
---
