---
# Check git merge conflict marker
inputs:
  docfx.yml:
  docs/a.md: |
    <<<<<<< HEAD
    foo
    =======
    bar
    >>>>>>> cb1abc6bd98cfc84317f8aa95a7662815417802d
outputs:
  docs/a.json:
  .errors.log: |
    ["suggestion","merge-conflict","File contains merge conflict markers. NOTE: This Suggestion will become a Warning on 06/30/2020.","docs/a.md",1,1]
---
# Ignore git merge conflict marker inside code blocks
inputs:
  docfx.yml:
  docs/a.md: |
    a

    ```markdown
    <<<<<<< HEAD
    ...
    =======
    ...
    >>>>>>> 1d82c7efe18f86136247fb366df5030843199c19
    ```
outputs:
  docs/a.json:
---
# Metadata value must be scalar or scalar array
inputs:
  docfx.yml: |
    globalMetadata:
      key1: {}
    fileMetadata:
      key2:
        '**/*':
          - a: 1
  a.md:
outputs:
  .errors.log: |
    ["error","invalid-metadata-type","Metadata 'key1' can only be a scalar value or string array","docfx.yml",2,9]
    ["error","invalid-metadata-type","Metadata 'key2' can only be a scalar value or string array","docfx.yml",6,7]
---
# Additional metadata validation from external JSON schema
inputs:
  docfx.yml: |
    metadataSchema: schema.json
    globalMetadata:
      key1: []
    fileMetadata:
      key2:
        '**/*': XNAGameStudio
  schema.json: |
    {
      "properties":{
        "key1": { "type": "string" },
        "key2": { "type": "string", "enum": ["VS", "MSDN"] },
        "key3": { "type": "integer" }
      }
    }
  a.md: |
    ---
    key3: net462
    ---
outputs:
  a.json: |
    {
      "key1": [],
      "key2": "XNAGameStudio",
      "key3": "net462"
    }
  .errors.log: |
    ["warning","unexpected-type","Expected type 'String' but got 'Array'","docfx.yml",3,9]
    ["warning","invalid-value","Invalid value for 'key2': 'XNAGameStudio'","docfx.yml",6,13]
    ["warning","unexpected-type","Expected type 'Integer' but got 'String'","a.md",2,7]
---
# Report missing-attribute at file level when yaml header missing
inputs:
  docfx.yml: |
    metadataSchema: schema.json
  schema.json: |
    { "required": ["a"] }
  a.md:
  b.md: |
    ---
    ---
outputs:
  a.json:
  b.json:
  .errors.log: |
    ["warning","missing-attribute","Missing required attribute: 'a'","a.md",1,1]
    ["warning","missing-attribute","Missing required attribute: 'a'","b.md",1,1]
---
# Allow multiple metadata schema definitions
inputs:
  docfx.yml: |
    metadataSchema:
      - schema1.json
      - schema2.json
  schema1.json: |
    { "required": ["a"] }
  schema2.json: |
    { "properties": { "key": { "type": "string" } } }
  a.md: |
    ---
    key: []
    ---
outputs:
  a.json:
  .errors.log: |
    ["warning","missing-attribute","Missing required attribute: 'a'","a.md",2,1]
    ["warning","unexpected-type","Expected type 'String' but got 'Array'","a.md",2,6]
---
# Validate each metadata schema individually for multiple metadata schema definitions
inputs:
  docfx.yml: |
    metadataSchema:
      - schema1.json
      - schema2.json
  schema1.json: |
    { "required": ["a"], "properties": { "key": { "type": "string" } } }
  schema2.json: |
    { "required": ["b"], "properties": { "key": { "type": "array" } } }
  a.md: |
    ---
    key: 1
    ---
outputs:
  a.json:
  .errors.log: |
    ["warning","missing-attribute","Missing required attribute: 'a'","a.md",2,1]
    ["warning","unexpected-type","Expected type 'String' but got 'Integer'","a.md",2,6]
    ["warning","missing-attribute","Missing required attribute: 'b'","a.md",2,1]
    ["warning","unexpected-type","Expected type 'Array' but got 'Integer'","a.md",2,6]
---
# Json schema microsoft alias rule: Mute error, when no connection with Graph API
inputs:
  docfx.yml: |
    metadataSchema:
      - schema.json
  schema.json: |
    { 
      "properties":
      { 
        "ms.author":
        { 
          "microsoftAlias": 
          {
            "allowedDLs":[]
          }
        }
      } 
    }
  a.md: |
    ---
    ms.author: over123
    ---
outputs:
  a.json: |
    { "ms.author": "over123" }
---
# Json schema microsoft alias rule: The author is in the allow list
inputs:
  docfx.yml: |
    metadataSchema:
      - schema.json
    microsoftGraphClientSecret: {MICROSOFT_GRAPH_CLIENT_SECRET}
  schema.json: |
    { 
      "properties":
      { 
        "ms.author":
        { 
          "microsoftAlias": 
          {
            "allowedDLs":["amlstudiodocs", "over123"]
          }
        }
      } 
    }
  a.md: |
    ---
    ms.author: over123
    ---
environments:
  - MICROSOFT_GRAPH_CLIENT_SECRET
outputs:
  a.json: |
    { "ms.author": "over123" }
---
# Json schema microsoft alias rule: The author is in the cache
inputs:
  docfx.yml: |
    metadataSchema:
      - schema.json
    microsoftGraphClientSecret: {MICROSOFT_GRAPH_CLIENT_SECRET}
  schema.json: |
    { 
      "properties":
      { 
        "ms.author":
        { 
          "microsoftAlias": 
          {
            "allowedDLs":[]
          }
        }
      } 
    }
  a.md: |
    ---
    ms.author: over123
    ---
cache:
  microsoft-graph.json: |
    { 
      "items": [
        { "alias": "over123" },
        { "alias": "zikun", "updated_at": "2018-06-08T01:40:33.1981669Z" }
      ]
    }
environments:
  - MICROSOFT_GRAPH_CLIENT_SECRET
outputs:
  a.json: |
    { "ms.author": "over123" }
---
# Json schema microsoft alias rule: The author information has expired 
inputs:
  docfx.yml: |
    metadataSchema:
      - schema.json
    microsoftGraphClientSecret: {MICROSOFT_GRAPH_CLIENT_SECRET}
  schema.json: |
    { 
      "properties":
      { 
        "ms.author":
        { 
          "microsoftAlias": 
          {
            "allowedDLs":[]
          }
        }
      } 
    }
  a.md: |
    ---
    ms.author: 123over123
    ---
cache:
  microsoft-graph.json: |
    { 
      "items": [
        { "alias": "yazhao" },
        { "alias": "123over123", "updated_at": "2018-06-08T01:40:33.1981669Z" }
      ]
    }
environments:
  - MICROSOFT_GRAPH_CLIENT_SECRET
outputs:
  a.json:
---
# Json schema microsoft alias rule: The author is valid with graph call 
inputs:
  docfx.yml: |
    metadataSchema:
      - schema.json
    microsoftGraphClientSecret: {MICROSOFT_GRAPH_CLIENT_SECRET}
  schema.json: |
    { 
      "properties":
      { 
        "ms.author":
        { 
          "microsoftAlias": 
          {
            "allowedDLs":[]
          }
        }
      } 
    }
  a.md: |
    ---
    ms.author: yazhao
    ---
environments:
  - MICROSOFT_GRAPH_CLIENT_SECRET
outputs:
  a.json: |
    { "ms.author": "yazhao" }
---
# Json schema microsoft alias rule: The author is invalid with graph call 
inputs:
  docfx.yml: |
    metadataSchema:
      - schema.json
    microsoftGraphClientSecret: {MICROSOFT_GRAPH_CLIENT_SECRET}
  schema.json: |
    { 
      "properties":
      { 
        "ms.author":
        { 
          "microsoftAlias": 
          {
            "allowedDLs":[]
          }
        }
      } 
    }
  a.md: |
    ---
    ms.author: abc1234cba
    ---
environments:
  - MICROSOFT_GRAPH_CLIENT_SECRET
outputs:
  a.json:
  .errors.log: |
    ["warning","ms-alias-invalid","Invalid value for 'ms.author', 'abc1234cba' is not a valid Microsoft alias","a.md",2,12]
---
# Content validation end to end scenario 
inputs:
  docfx.yml: |
    markdownValidationRules: rules.json
  rules.json: |
    {
      "headings": {
        "name": "Headings",
        "description": "Validates H1 and other heading content",
        "aliases": null,
        "rules": [
          {
            "type": "H1Missing",
            "message": "H1 is required. Use a single hash (#) followed by a space to create your top-level heading.",
            "exclusions": [ "toc", "includes", "hubpage", "landingpage" ],
            "severity": "WARNING",
            "code": "h1-missing"
          }
        ]
      }
    }
  a.md: |
    This is test.
outputs:
  a.json:
  .errors.log: |
    ["warning","h1-missing","H1 is required. Use a single hash (#) followed by a space to create your top-level heading.","a.md",1]
---
# Validate included markdown files within Yaml file
inputs:
  docfx.yml: |
    markdownValidationRules: rules.json
  rules.json: |
    {
      "headings": {
        "name": "Headings",
        "description": "Validates H1 and other heading content",
        "aliases": null,
        "rules": [
          {
            "type": "H1Missing",
            "message": "H1 is required. Use a single hash (#) followed by a space to create your top-level heading.",
            "exclusions": [],
            "severity": "WARNING",
            "code": "h1-missing"
          }
        ]
      }
    }
  docs/a.yml: |
    #YamlMime:YamlDocument
    documentType: LandingData
    title: my title
    content: |
      [!include[](b.md)]
  docs/b.md: |
    This is test.
outputs:
  docs/a.json: |
    {
      "title": "my title"
    }
  docs/b.json:
  .errors.log: |
    ["warning","h1-missing","H1 is required. Use a single hash (#) followed by a space to create your top-level heading.","docs/b.md",1]
---
# Skip content validation for yaml files
inputs:
  docfx.yml: |
    markdownValidationRules: rules.json
  rules.json: |
    {
      "headings": {
        "name": "Headings",
        "description": "Validates H1 and other heading content",
        "aliases": null,
        "rules": [
          {
            "type": "H1Missing",
            "message": "H1 is required. Use a single hash (#) followed by a space to create your top-level heading.",
            "exclusions": [],
            "severity": "WARNING",
            "code": "h1-missing"
          }
        ]
      }
    }
  docs/a.yml: |
    #YamlMime:YamlDocument
    documentType: LandingData
    title: my title
    abstract:
      description: this is test.
outputs:
  docs/a.json: |
    {
      "title": "my title"
    }
---
# Json schema docset unique: the attribute value must be unique within docset
inputs:
  docfx.yml: |
    metadataSchema:
      - schema.json
  schema.json: |
    {
      "docsetUnique": [ "title", "description"]
    }
  a.md: |
    ---
    title: title1
    description: description1
    ---
  b.md: |
    ---
    description: description1
    title: title2
    ---
outputs:
  a.json:
  b.json:
  .errors.log: |
    ["suggestion","duplicate-attribute","Attribute 'description' with value 'description1' is duplicated in 'a.md(3,14)', 'b.md(2,14)'","b.md",2,14]
    ["suggestion","duplicate-attribute","Attribute 'description' with value 'description1' is duplicated in 'a.md(3,14)', 'b.md(2,14)'","a.md",3,14]
---
# Json schema docset unique: null/empty values are not in-scope
inputs:
  docfx.yml: |
    metadataSchema:
      - schema.json
  schema.json: |
    {
      "docsetUnique": [ "title", "description"]
    }
  a.md: |
    ---
    title: null
    description:
    ---
  b.md: |
    ---
    description:
    title: null
    ---
outputs:
  a.json:
  b.json:
---
# Json schema docset unique: global metadata and file metadata
inputs:
  docfx.yml: |
    metadataSchema:
      - schema.json
    globalMetadata:
      description: abc
  schema.json: |
    {
      "docsetUnique": ["description"]
    }
  a.md: |
    ---
    description: abc
    ---
  b.md:
outputs:
  a.json:
  b.json:
  .errors.log: |
    ["suggestion","duplicate-attribute","Attribute 'description' with value 'abc' is duplicated in 'a.md(2,14)', 'docfx.yml(4,16)'","a.md",2,14]
    ["suggestion","duplicate-attribute","Attribute 'description' with value 'abc' is duplicated in 'a.md(2,14)', 'docfx.yml(4,16)'","docfx.yml",4,16]
---
# Json schema length rule: the length of string must be in range of MinLength and MaxLength
inputs:
  docfx.yml: |
    metadataSchema:
      - schema.json
  schema.json: |
    { 
      "properties":
      { 
        "description": {
          "type": [
            "string",
            "null"
          ],
          "minLength": 2,
          "maxLength": 10
        }
      }
    }
  a.md: |
    ---
    description: a
    ---
  b.md: |
    ---
    description: a long description
    ---
outputs:
  a.json:
  b.json:
  .errors.log: |
    ["warning","string-length-invalid","String 'description' length should be >= 2","a.md",2,14]
    ["warning","string-length-invalid","String 'description' length should be <= 10","b.md",2,14]
---
# Content validation - H1 unique
inputs:
  docfx.yml: |
    markdownValidationRules: rules.json
  rules.json: |
    {
      "headings": {
        "name": "Headings",
        "description": "Validates H1 and other heading content",
        "aliases": null,
        "rules": [
          {
            "type": "H1Unique",
            "message": "H1 '{0}' is duplicated with other articles: '{1}'",
            "code": "duplicate-h1",
            "severity": "SUGGESTION",
            "exclusions": [
              "includes",
              "landingPage",
              "hubPage",
              "toc"
            ],
            "excludedDocfxVersions": [
              "v2"
            ]
          }
        ]
      }
    }
  a.md: |
    # Title 1
  b.md: |
    # Title 1
  c.md: |
    # Title 2
outputs:
  a.json:
  b.json:
  c.json:
  .errors.log: |
    ["suggestion","duplicate-h1","H1 'Title 1' is duplicated with other articles: 'a.md, b.md'","a.md"]
    ["suggestion","duplicate-h1","H1 'Title 1' is duplicated with other articles: 'a.md, b.md'","b.md"]
---
# Content validation - Publish Url - max level
# Validation is only worked in the conceptual page
inputs:
  docfx.yml: |
    monikerRange:
      'v1/**': '< netcore-2.0'
      'v2/**': '>= netcore-2.0'
    markdownValidationRules: rules.json
    basePath: /docs
    routes:
      v1/: folder/
      v2/: folder/
      folder0/: folder/
    monikerDefinition: monikerDefinition.json
  monikerDefinition.json: |
    {
      "monikers": [
        { "moniker_name": "netcore-1.0", "product_name": ".NET Core" },
        { "moniker_name": "netcore-2.0", "product_name": ".NET Core" },
      ]
    }
  redirections.yml: |
    redirections:
      folder0/folder1/folder2/c.md: "docs/folder/folder1/c"
  rules.json: |
    {
      "publishurls": {
        "name": "PublishUrls",
        "description": "Validates publish urls",
        "aliases": null,
        "rules": [
          {
            "type": "MaxLevel",
            "message": "Article URL '{0}' is '{1}' levels deep. For SEO, URLs should be '{2}' levels or fewer.",
            "code": "path-too-deep",
            "severity": "SUGGESTION",
            "exclusions": [
              "includes",
              "landingPage",
              "hubPage",
              "toc",
              "redirection"
            ],
            "excludedDocfxVersions": [
              "v2"
            ],
            "maxLevel": 4
          }
        ]
      }
    }
  folder0/folder1/folder2/index.md:  
  v1/folder1/folder2/a.md: |
    Moniker: netcore-1.0
  v2/folder1/folder2/a.md: |
    Moniker: netcore-2.0
  folder0/folder1/folder2/TOC.md:
  folder0/b.md: '![](folder1/folder2/image.png)'
  folder0/folder1/folder2/image.png:
outputs:
  docs/folder/folder1/folder2/index.json:
  docs/136a42ac/folder/folder1/folder2/a.json: 
  docs/4667fedf/folder/folder1/folder2/a.json: 
  docs/folder/folder1/folder2/toc.json:
  docs/folder/b.json: |
    {"conceptual": "<p><img src=\"folder1/folder2/image.png\" alt=\"\" data-linktype=\"relative-path\"></p>"}
  docs/folder/folder1/folder2/image.png:
  .errors.log: |
    ["suggestion","path-too-deep","Article URL '/docs/folder/folder1/folder2/' is '5' levels deep. For SEO, URLs should be '4' levels or fewer.", "folder0/folder1/folder2/index.md"]
    ["suggestion","path-too-deep","Article URL '/docs/folder/folder1/folder2/a' is '5' levels deep. For SEO, URLs should be '4' levels or fewer.", "v1/folder1/folder2/a.md"]
    ["suggestion","path-too-deep","Article URL '/docs/folder/folder1/folder2/a' is '5' levels deep. For SEO, URLs should be '4' levels or fewer.", "v2/folder1/folder2/a.md"]
---
