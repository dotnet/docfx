---
# Support schema documents in YAML format
inputs:
  docfx.yml:
  docs/a.yml: |
    #YamlMime:LandingData
    title: my title
    metadata:
      key: value
outputs:
  docs/a.json: |
    {
      "title": "my title",
      "key": "value"
    }
---
# Support schema documents in JSON format
inputs:
  docfx.yml:
  docs/a.json: |
    {
      "$schema": "https://raw.githubusercontent.com/dotnet/docfx/v3/schemas/LandingData.json",
      "title": "my title",
      "metadata": { "key": "value" }
    }
outputs:
  docs/a.json: |
    { 
      "title": "my title",
      "key": "value" 
    }
---
# Throw error when schema is not specified
inputs:
  docfx.yml:
  docs/a.yml: |
    title: my title
  docs/b.json: |
    {
      "a": 1,
      "$schema": "https://raw.githubusercontent.com/dotnet/docfx/v3/schemas/LandingData.json"
    }
outputs:
  .errors.log: |
   ["error","schema-not-found","Unknown schema ''","docs/a.yml",1,1]
   ["error","schema-not-found","Unknown schema ''","docs/b.json",1,1]
---
# Fallback to documentType when yaml mime is YamlDocument
inputs:
  docfx.yml:
  docs/a.yml: |
    #YamlMime:YamlDocument
    documentType: LandingData
    title: my title
outputs:
  docs/a.json: |
    {
      "title": "my title"
    }
---
# Throw error when defined schema is not found
inputs:
  docfx.yml:
  docs/a.yml: |
    #YamlMime:SchemaNotExisting
    title: my title
  docs/b.json: |
    {
      "$schema": "https://raw.githubusercontent.com/dotnet/docfx/v3/schemas/SchemaNotExisting.json",
    }
  docs/c.json: |
    { "$schema": "https://raw.githubusercontent.com/dotnet/docfx/v3/schemas/SchemaNotExisting.json"}
outputs:
  .errors.log: |
   ["error","schema-not-found","Schema 'SchemaNotExisting' not found.","docs/a.yml",1,1]
   ["error","schema-not-found","Schema 'SchemaNotExisting' not found.","docs/b.json",2,95]
   ["error","schema-not-found","Schema 'SchemaNotExisting' not found.","docs/c.json",1,95]
---
# Support schema documents with Href content
inputs:
  docfx.yml:
  docs/A/TOC.yml:
  docs/TOC.yml:
  docs/a.yml: |
    #YamlMime:ContextObject
    brand: azure
    breadcrumb_path: TOC.yml
    toc_rel: A/TOC.yml
  _themes/ContentTemplate/schemas/ContextObject.schema.json: |
    {
      "type": "object",
      "properties": {
          "breadcrumb_path": {"contentType": "Href"},
          "toc_rel": {"contentType": "Href"},
      }
    }
outputs:
  docs/toc.json:
  docs/a/toc.json:
  docs/a.json: |
    {
      "brand": "azure",
      "breadcrumb_path": "toc.json",
      "toc_rel": "a/toc.json"
    }
  .dependencymap.json: |
      {
         "dependencies":{
            "docs/a.yml":[
               { "source": "docs/A/TOC.yml", "type": "link" },
               { "source": "docs/TOC.yml", "type": "link" }
            ]
         }
      }
---
# schema documents with Href content but wrong type
inputs:
  docfx.yml:
  TOC.yml:
  docs/TOC.yml:
  docs/a.yml: |
    #YamlMime:ContextObject
    brand: azure
    breadcrumb_path: {}
    toc_rel: ../TOC.yml
  _themes/ContentTemplate/schemas/ContextObject.schema.json: |
    {
      "type": "object",
      "properties": {
          "breadcrumb_path": {"type": "string", "contentType": "Href"},
          "toc_rel": {"type": "string", "contentType": "Href"},
      }
    }
outputs:
  docs/a.json:
  toc.json:
  docs/toc.json:
  .errors.log: |
    ["warning","unexpected-type","Expect type 'String' but got 'Object'","docs/a.yml",3,18]
---
# Schema documents with Href content referencing resource file, the resouce file should be outputed
inputs:
  docfx.yml:
  docs/a.yml: |
    #YamlMime:TestPage
    href: image.png
  docs/image.png:
  _themes/ContentTemplate/TestPage.html.primary.js:
  _themes/ContentTemplate/schemas/TestPage.schema.json: |
    {
      "type": "object",
      "properties": {
        "href": {"contentType": "href"}
      }
    }
outputs:
  docs/a.json: |
    {"href": "image.png"}
  docs/image.png:
---
# Support schema documents with Markdown content
inputs:
  docfx.yml:
  docs/index.yml: |
    #YamlMime:TestPage
    description: Hello `docfx`! <a href="a.md">a</a>
  docs/a.md:
  _themes/ContentTemplate/TestPage.html.primary.js:
  _themes/ContentTemplate/schemas/TestPage.schema.json: |
    {
      "type": "object",
      "properties": {
        "description": {"contentType": "Markdown"}
      }
    }
outputs:
  docs/index.json: |
    { "description": "<p>Hello <code>docfx</code>! <a href=\"a\">a</a></p>" }
  docs/a.json:
---
# Markdown content with null value
inputs:
  docfx.yml:
  docs/a.yml: |
    #YamlMime:TestPage
    description:
  _themes/ContentTemplate/TestPage.html.primary.js:
  _themes/ContentTemplate/schemas/TestPage.schema.json: |
    {
      "type": "object",
      "properties": {
        "description": {"type": "string"}
      }
    }
outputs:
  docs/a.json:
  .errors.log: |
    ["warning","unexpected-type","Expect type 'String' but got 'Null'","docs/a.yml",2,13]
---
# Support schema documents with inline markdown content
inputs:
  docfx.yml: |
    rules:
      heading-not-found: error
  docs/a.yml: |
    #YamlMime:TestPage
    inlineDescription: >
      This is a list:
        - Item 1
        - Item 2
        - `Item 3`

      ## Not heading
  _themes/ContentTemplate/TestPage.html.primary.js:
  _themes/ContentTemplate/schemas/TestPage.schema.json: |
    {
      "type": "object",
      "properties": {
        "inlineDescription": {"contentType": "InlineMarkdown"}
      }
    }
outputs:
  docs/a.json: |
    { "inlineDescription": "This is a list:\n- Item 1\n- Item 2\n- <code>Item 3</code>## Not heading" }
---
# [skip] Support schema documents with html content
inputs:
  docfx.yml:
  docs/a.yml: |
    #YamlMime:TestPage
    html: link <a href="b.md"></a> <script></script>
  docs/b.md:
outputs:
  docs/a.json: |
    { "html": "link <a href=\"b\"></a>" }
  docs/b.json:
---
# Support schema documents with href content
inputs:
  docfx.yml:
  docs/a.yml: |
    #YamlMime:TestPage
    href: b.md
  docs/b.md:
  _themes/ContentTemplate/schemas/TestPage.schema.json: |
    {
      "type": "object",
      "properties": {
        "href": {"contentType": "href"}
      }
    }
outputs:
  docs/a.json: |
    { "href": "b" }
  docs/b.json:
---
# Output data schema to json, output page schema to html
inputs:
  docfx.yml:
  docs/a.md: |
    link to [data](data.yml) or [page](page.yml)
  docs/data.yml: |
    #YamlMime:TestData
  docs/page.yml: |
    #YamlMime:TestPage
  _themes/ContentTemplate/schemas/TestData.schema.json: "{}"
  _themes/ContentTemplate/TestPage.html.primary.js:
  _themes/ContentTemplate/schemas/TestPage.schema.json: "{}"
outputs:
  docs/a.json: |
    { "conceptual": "<p>link to <a href=\"data.json\"> data</a> or <a href=\"page\"> page</a></p>" }
  docs/data.json:
  docs/page.json:
---
# Markdown field with heading should not be removed
inputs:
  docfx.yml:
  docs/data.yml: |
    #YamlMime:TestData
  docs/page.yml: |
    #YamlMime:TestPage
    description: >
      # Heading
  _themes/ContentTemplate/schemas/TestData.schema.json: "{}"
  _themes/ContentTemplate/TestPage.html.primary.js:
  _themes/ContentTemplate/schemas/TestPage.schema.json: |
    {
      "type": "object",
      "properties": {
        "description": {"contentType": "Markdown"}
      }
    }
outputs:
  docs/data.json:
  docs/page.json: |
    {
      "description": "<h1 id=\"heading\">Heading</h1>"
    }
---
# Show yaml, json syntax error
inputs:
  docfx.yml:
  docs/a.yml: |
    #YamlMime:TestData
    a: b:
  docs/b.json: |
    {
outputs:
  .errors.log: |
    ["error","yaml-syntax-error","Mapping values are not allowed in this context.","docs/a.yml",2,5]
    ["error","json-syntax-error","Error reading JObject from JsonReader.","docs/b.json",2]
---
# Invalid JSON
inputs:
  docfx.yml:
  docs/a.json: |
    {a}/{b}/{c}
outputs:
  .errors.log: |
    ["error","json-syntax-error","Invalid JavaScript property identifier character: }.","docs/a.json",1,2]
---
# Run data-transform if provided, by default return {"content": "serialized json"}
inputs:
  docfx.yml:
  a.yml: |
    #YamlMime:TestData
    prop: value
  _themes/ContentTemplate/TestData.json.js: |
    exports.transform = function (model) {
      return {
        content: JSON.stringify({result: model.prop + " has run js data transform"})
      }
    }
  _themes/ContentTemplate/schemas/TestData.schema.json: "{}"
outputs:
  a.json: |
    {"result": "value has run js data transform"}
---
# Run data-transform if provided, and return raw object if content property is not serialized json object
inputs:
  docfx.yml:
  a.yml: |
    #YamlMime:TestData
    prop: value
  _themes/ContentTemplate/TestData.json.js: |
    exports.transform = function (model) {
      return {
        result: model.prop + " has run js data transform",
        content: "raw string"
      }
    }
  _themes/ContentTemplate/schemas/TestData.schema.json: "{}"
outputs:
  a.json: |
    {
      "result": "value has run js data transform",
      "content": "raw string"
    }
---
# Don't run data-transform if corresponding js not provided
inputs:
  docfx.yml:
  a.yml: |
    #YamlMime:TestData
    prop: value
  _themes/ContentTemplate/schemas/TestData.schema.json: "{}"
outputs:
  a.json: |
    {"prop": "value"}
---
# Throw error when content is not an object
inputs:
  docfx.yml:
  _themes/ContentTemplate/schemas/test.schema.json: '{}'
  a.yml: |
    #YamlMime:test
    - array
outputs:
  .errors.log: |
    ["error","unexpected-type","Expect type 'Object' but got 'Array'","a.yml",1,1]
---
# Verify SDP pipeline
inputs:
  docfx.yml: |
    output:
      json: false
  _themes/ContentTemplate/schemas/TestData.schema.json: "{}"
  a.yml: |
    #YamlMime:TestData
    prop: value
    layout: test
  _themes/ContentTemplate/TestData.html.primary.tmpl: |
    <div>{{content}}</div>
  _themes/ContentTemplate/TestData.html.primary.js: |
    exports.transform = function (model) {
      return model.prop;
    }
  _themes/ContentTemplate/test.html.liquid: |
    <!DOCTYPE html>
      <div>
          {{content}}
      </div>
outputs:
  a/index.html: |
    <!DOCTYPE html>
      <div>
        <div>value</div>

      </div>
